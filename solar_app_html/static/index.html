<!-- index.html -->
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PV Map (Local)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

  <style>
    body { margin: 0; font-family: sans-serif; }
    #wrap { display: grid; grid-template-columns: 380px 1fr; height: 100vh; }
    #side { padding: 12px; border-right: 1px solid #ddd; overflow: auto; }
    #map { height: 100vh; cursor: crosshair; }
    #bevaringskodeBox {
      font-size: 13px;
      padding: 8px 10px;
      border: 1px solid #ddd;
      border-radius: 10px;
      background: #fff;
      margin: 8px 0;
    }

    .row { margin-bottom: 10px; }
    label { display: block; font-size: 12px; color: #444; margin-bottom: 4px; }
    input, select { width: 100%; padding: 6px; box-sizing: border-box; }
    button { padding: 10px; width: 100%; margin-bottom: 8px; }
    pre { background: #dddddd; padding: 10px; white-space: pre-wrap; }

    .small { font-size: 12px; color: #555; }
    .hr { height: 1px; background: #dddddd; margin: 10px 0; }
    #plans { font-size: 13px; }
    .planItem {
      border: 1px solid #ddd;
      border-radius: 8px;
      margin: 8px 0;
      background: #fff;
      overflow: hidden;
    }
    .planItem summary {
      cursor: pointer;
      padding: 10px;
      background: #f7f7f7;
      font-weight: 600;
      outline: none;
    }
    .planBody {
      padding: 10px;
    }
    .kv {
      display: grid;
      grid-template-columns: 140px 1fr;
      gap: 6px 10px;
    }
    .kv .k { color: #555; font-size: 12px; }
    .kv .v { color: #111; word-break: break-word; }
    .kv a { color: #0b57d0; text-decoration: none; }
    .kv a:hover { text-decoration: underline; }
    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: #eee;
      font-size: 12px;
      margin-left: 8px;
    }

    #summary { font-size: 13px; }

    .section {
      border: 1px solid #ddd;
      border-radius: 10px;
      margin: 8px 0;
      overflow: visible;
      background: #fff;
    }

    .section summary {
      cursor: pointer;
      padding: 10px;
      background: #f7f7f7;
      font-weight: 700;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .section .body { padding: 10px; }

    .warnPill{
      display:inline-block;
      padding:2px 8px;
      margin-left:6px;
      border-radius:999px;
      background:#fff3cd;
      color:#7a5c00;
      font-size:12px;
      font-weight:600;
    }

    .row2 {
      display: grid;
      grid-template-columns: 160px 1fr;
      gap: 6px 10px;
      align-items: start;
    }
    .row2 .k { color: #555; font-size: 12px; }
    .row2 .v { color: #111; word-break: break-word; }

    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: #eee;
      font-size: 12px;
      font-weight: 600;
      margin-left: 8px;
    }

    .detailSection{
      border: 1px solid #e6e6e6;
      border-radius: 10px;
      padding: 10px;
      margin: 10px 0;
      background: #fafafa;
    }

    .detailTitle{
      font-weight: 700;
      margin-bottom: 8px;
    }

    .detailRow{
      display: grid;
      grid-template-columns: 110px 1fr;
      gap: 8px;
      padding: 6px 0;
      border-top: 1px solid #eee;
    }

    .detailRow:first-child{ border-top: none; }

    .detailLabel{
      font-size: 12px;
      color: #555;
    }

    .detailValue{
      font-size: 13px;
      color: #111;
      white-space: pre-wrap;
      line-height: 1.35;
    }


    /* Tooltip */
    .qm {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      border-radius: 999px;
      border: 1px solid #bbb;
      font-size: 11px;
      color: #555;
      margin-left: 6px;
      cursor: help;
      position: relative;
      user-select: none;
    }

    .qm::after {
      content: attr(data-tip);
      position: absolute;
      left: 0px;
      top: 22px;
      min-width: 220px;
      max-width: 320px;
      white-space: normal;
      background: #111;
      color: #fff;
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 12px;
      line-height: 1.3;
      opacity: 0;
      pointer-events: none;
      transform: translateY(4px);
      transition: opacity 0.15s ease, transform 0.15s ease;
      z-index: 9999;
    }

    .qm:hover::after {
      opacity: 1;
      transform: translateY(0);
    }

    /* Geocoder search box styling */
    .leaflet-control-geocoder {
      width: 260px !important;
    }

    .leaflet-control-geocoder input {
      width: 100% !important;
      height: 36px;
      font-size: 14px;
      padding: 6px 10px;
      border-radius: 8px;
    }

    /* softer placeholder look */
    .leaflet-control-geocoder input::placeholder {
      color: #666;
      opacity: 0.6;
    }

    .leaflet-control-geocoder-icon {
      display: none;
    }

    /* --- Layers control styling --- */
    .leaflet-control-layers {
      border-radius: 10px;
      overflow: hidden;
    }

    /* Title row inside the control */
    .layers-title {
      font-weight: 700;
      padding: 8px 10px;
      background: #f7f7f7;
      border-bottom: 1px solid #e6e6e6;
    }

    /* Make each overlay line a clean 3-column row: toggle | name | swatch */
    .leaflet-control-layers-overlays label {
      display: grid;
      grid-template-columns: 18px 1fr 18px;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      margin: 0;
      line-height: 1.2;
    }

    /* Keep checkbox aligned and not stretched */
    .leaflet-control-layers-overlays input[type="checkbox"] {
      margin: 0;
      justify-self: start;
    }

    /* Ensure the name doesn't collide with swatch */
    .leaflet-control-layers-overlays label .layer-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Put swatch on the right */
    .layer-swatch {
      width: 14px;
      height: 14px;
      border-radius: 4px;
      border: 2px solid #666;
      margin: 0;
      justify-self: end;
    }

    /* Modal */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 99999;
    }
    .modalCard {
      width: min(1100px, 96vw);
      max-height: 92vh;
      background: #fff;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 10px 40px rgba(0,0,0,0.25);
      display: flex;
      flex-direction: column;
    }
    .modalHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: #f7f7f7;
      border-bottom: 1px solid #e6e6e6;
    }
    .modalClose {
      padding: 8px 10px;
      width: auto;
      margin: 0;
    }
    .modalBody {
      padding: 12px;
      overflow: auto;
    }
    .modalGrid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .modalPanel {
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 10px;
      background: #fff;
    }

    /* ===== Fix Leaflet layers control being affected by global form styles ===== */
    .leaflet-control-layers input,
    .leaflet-control-layers select {
      width: auto !important;
      padding: 0 !important;
      box-sizing: content-box !important;
    }

    .leaflet-control-layers label {
      margin-bottom: 0 !important; /* your global label rule adds spacing */
    }

    /* Base layers: spacing between radio and text (needs span wrapper from JS below) */
    .leaflet-control-layers .leaflet-control-layers-base label span.layer-name {
      margin-left: 8px !important; /* match overlay "gap: 8px" */
    }

    /* Base layers: align radio + wrapped label text */
    .leaflet-control-layers .leaflet-control-layers-base label {
      display: flex;
      align-items: center;
      padding: 6px 10px;
      margin: 0;
      white-space: nowrap;
    }
    .leaflet-control-layers .leaflet-control-layers-base input[type="radio"] {
      margin: 0;
    }

    /* ===== Azimuth measurement tool ===== */

    .az-arrow-head {
      font-size: 18px;
      line-height: 18px;
      color: #111;
      text-shadow: 0 1px 2px rgba(255,255,255,0.9);
      transform-origin: 50% 60%;
    }

    .az-tip div {
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 4px 8px;
      border-radius: 8px;
      font-size: 12px;
      white-space: nowrap;
    }

    .az-btn {
      padding: 8px 10px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 8px;
      cursor: pointer;
    }

    .az-btn.active {
      background: #111;
      color: #fff;
    }


    @media (max-width: 900px) {
      .modalGrid { grid-template-columns: 1fr; }
    }
    
  </style>
</head>

<body>
<div id="wrap">
  <!-- Monthly modal -->
  <div id="monthlyModal" class="modal" style="display:none;">
    <div class="modalCard">
      <div class="modalHeader">
        <div id="monthlyTitle" style="font-weight:700;">Månedlig oversigt</div>
        <button id="btnMonthlyClose" class="modalClose">Close</button>
      </div>

      <div class="modalBody">
        <div class="modalGrid">
          <div class="modalPanel">
            <div class="small"><b>Estimeret El-Energi balance (kWh)</b></div>
            <canvas id="chartMonthlyEnergy"></canvas>
          </div>

          <div class="modalPanel">
            <div class="small"><b>Estimerede omkostninger og besparelser (DKK)</b></div>
            <canvas id="chartMonthlyCost"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>  
  <div id="side">
    <h1>Inputs</h1>
    <h3>(Indsæt vejledning / dokumentation)</h3>

    <details class="section" open>
      <summary>Indstillinger for anlæg</summary>
      <div class="body">
        <div class="row">
          <label><b>Årlig forbrug (kWh/år)</b></label>
          <input id="annual_kwh" type="number" value="4200" step="100" min="0">
          <label>Indtast dit årlige forbrug (husstand)</label>
          <div class="hr"></div>
        </div>

        <div class="row">
          <label><b>Solpanel størrelse (kWp)</b></label>
          <input id="kwp" type="number" step="0.1" value="1.0" min="0">
          <label>Indtast størrelse for solpanel</label>
          <div class="hr"></div>
        </div>

        <div class="row">
          <label><b>Batteri kapacitet (kWh) (0 = intet batteri)</b></label>
          <input id="batt_kwh" type="number" step="0.5" value="0" min="0">
          <label>Indtast størrelse på batteripakke</label>
          <div class="hr"></div>
        </div>

        <div class="row">
          <label><b>Pris-scenarie</b></label>
          <select id="price_scenario">
            <option value="2025_real" selected>2025 (Historisk: elafgift 0,72 dkk/kWh)</option>
            <option value="2026_projection">2026 (Fremskrevet: elafgift 0,01 dkk/kWh)</option>
          </select>
          <label>Vælg mellem:</label> 
          <label>2025 Historiske priser med elafgift på <b>0.72 dkk/kWh</b> </label> 
          <label>2026 Fremskrevede priser som er baseret på priser fra 2025 med sænket elafgift på <b>0.01 dkk/kWh</b></label>
        </div>

        <div class="row" id="row_elafgift_custom" style="display:none;">
          <label>Custom elafgift (DKK/kWh)</label>
          <input id="elafgift_custom" type="number" step="0.01" value="0.01" min="0">
        </div>

      </div>
    </details>

    <details class="section">
      <summary>Avancerede indstillinger</summary>
      <div class="body">
        <label>Herunder findes avancerede instillinger for solpanel og batteri. Disse indstillinger kan til en hvis grad ignoreres hvis der blot ønskes en overslagsberegning. Beregningen bliver mere retvisende hvis avancerede indstillinger er sat korrekt.</label>

        <details class="section" open>
          <summary>Avancerede Solpanel indstillinger</summary>
          <div class="body">
          <!-- PV advanced -->

          <div class="row">
            <label><b>Virkningsgrad (PR) (0.75 = 75%)</b></label>
            <input id="pr" type="number" step="0.01" value="0.75" min="0" max="1.2">
            <label>Virkningsgraden / Performance Ratio (PR) beskriver den overordnede effektivitet som solpanelet producerer elektricitet ved. Værdien vil typisk ligge mellem 0.75 til 0.85.</label>
            <div class="hr"></div>
          </div>

          <div class="row">
            <label><b>Hældning (°)</b></label>
            <input id="tilt" type="number" step="1" value="40">
            <label>Tagets hældning har betydning for solpanelets effektivitet. Hældningen på dit tag kan eventuelt findes i plantegningerne for dit hus, eller kan måles manuelt</label>
            <div class="hr"></div>
          </div>

          <div class="row">
            <label><b>Retning / azimuth (°) (180 = syd)</b></label>
            <input id="az" type="number" step="1" value="180">
            <label>Tagets retning / azimuth har betydning for solpanelets effektivitet. </label>
            <label>Brug eventuelt værktøjet <b>"Mål retning / azimuth"</b> (nederst til venstre på kortet) til at bestemme denne vinkel på dit tag. Klik på værktøjet og derefter klik på tagryggen af dit hus - træk derefter pilen væk fra dit hus (helst mod syd) så den røde linje ligger langs tagryggen.</label>
          </div>

          </div>
        </details>
        
        <details class="section" open>
          <summary>Avancerede Batteri indstillinger</summary>
          <div class="body">
            <!-- Battery advanced -->
          <div class="row">
            <label><b>Start SoC (0-1) (0.5 = 50% opladt)</b></label>
            <input id="soc_init" type="number" step="0.05" value="0.5" min="0" max="1">
            <label>State of Charge (SoC) bestemmer batteriets opladningsniveau når simuleringen startes.</label>
            <div class="hr"></div>
          </div>

          <div class="row">
            <label><b>Minimum SoC (0-1) (0.1 = 10% opladt)</b></label>
            <input id="soc_min" type="number" step="0.05" value="0.1" min="0" max="1">
            <label>Ved at begrænse minimum-opladningsniveau kan batteriets levetid forlænges</label>
            <div class="hr"></div>
          </div>

          <div class="row">
            <label><b>Maksimal SoC (0-1) (0.9 = 90% opladt)</b></label>
            <input id="soc_max" type="number" step="0.05" value="0.9" min="0" max="1">
            <label>Ved at begrænse maksimum-opladningsniveau kan batteriets levetid forlænges</label>
            <div class="hr"></div>
          </div>

          <div class="row">
            <label><b>Maksimal opladningseffekt (kW) (blank = uendelig)</b></label>
            <input id="p_charge_kw" type="number" step="0.5" value="" min="0">
            <label>Den maksimale opladningseffekt beskriver den effekt som batteriet maksimalt kan oplades med. Denne værdi er typisk en begrænsning der er sat af solpanelets inverter.</label>
            <div class="hr"></div>
          </div>

          <div class="row">
            <label><b>Maksimal afladningseffekt (kW) (blank = uendelig)</b></label>
            <input id="p_discharge_kw" type="number" step="0.5" value="" min="0">
            <label>Den maksimale afladningseffekt beskriver den effekt som batteriet maksimalt kan aflades med. Denne værdi er typisk en begrænsning der er sat af solpanelets inverter.</label>
            <div class="hr"></div>
          </div>

          <div class="row">
            <label><b>Opladnings effektivitet (0-1) (0.95 = 95%)</b></label>
            <input id="eta_c" type="number" step="0.01" value="0.95" min="0" max="1">
            <label>Opladnings effektivitet er den energi, der tilføres batteriet, divideret med den energi, der bruges af opladeren.</label>
            <div class="hr"></div>
          </div>

          <div class="row">
            <label><b>Afladnings effektivitet (0-1) (0.95 = 95%)</b></label>
            <input id="eta_d" type="number" step="0.01" value="0.95" min="0" max="1">
            <label>Afladnings effektivitet er den energi, der leveres fra batteriet, divideret med den energi, der tappes fra batteriet.</label>
          </div>

          </div>
        </details>

      </div>
    </details>


    <button id="btnSummary">Opdater oversigt</button>
    <button id="btnMonthly">Månedlig oversigt</button>

    <div class="hr"></div>
    <h1>Outputs</h1>
    <div class="small"><b>Status:</b> <span id="status">Klik på kort for at vælge lokation. Tryk derefter på Opdater oversigt.</span></div>
    <div class="small"><b>Valgt koordinat:</b> <span id="coord">—</span></div>

    <div id="summary"></div>
    <div class="hr"></div>
    <div id="simulationYear"></div>

    <div class="hr"></div>
    <h4 style="margin: 8px 0;">Lokalplaner</h4>
    <div id="bevaringskodeBox">Bevaringskategori:</div>
    <div id="plans"></div>
  </div>

  <div id="map"></div>
</div>

<script>
  const summaryEl = document.getElementById("summary");
  const plansEl = document.getElementById("plans");
  const coord = document.getElementById("coord");
  const statusEl = document.getElementById("status");

  const kwpEl = document.getElementById("kwp");
  const prEl = document.getElementById("pr");
  const tiltEl = document.getElementById("tilt");
  const azEl = document.getElementById("az");
  const annualKwhEl = document.getElementById("annual_kwh");

  const bevaringskodeEl = document.getElementById("bevaringskodeBox");

    //Simulering Solpanel
  const simBox = document.getElementById("simBox");
  const simYearEl = document.getElementById("simulationYear");

    //Simulering med Batteri
  const battKwhEl = document.getElementById("batt_kwh");
  const socInitEl = document.getElementById("soc_init");
  const socMinEl = document.getElementById("soc_min");
  const socMaxEl = document.getElementById("soc_max");
  const pChargeEl = document.getElementById("p_charge_kw");
  const pDischargeEl = document.getElementById("p_discharge_kw");
  const etaCEl = document.getElementById("eta_c");
  const etaDEl = document.getElementById("eta_d");

  const priceScenarioEl = document.getElementById("price_scenario");

  let selected = null;
  let marker = null;

  let lastYearSim = null;
  let chartMonthlyEnergy = null;
  let chartMonthlyCost = null;

  let lastSummary = null;

  async function getJSON(url) {
    const r = await fetch(url);
    if (!r.ok) throw new Error(await r.text());
    return await r.json();
  }

  function getDisplayYear() {
    const sc = priceScenarioEl ? priceScenarioEl.value : null;
    if (sc === "2025_real") return 2025;
    if (sc === "2026_projection") return 2026;
    return 2025; // fallback
  }

  function refreshYearLabels() {
    const y = getDisplayYear();

    const titleEl = document.getElementById("monthlyTitle");
    if (titleEl) titleEl.textContent = `Månedlig oversigt (${y})`;

    const btnEl = document.getElementById("btnMonthly");
    if (btnEl) btnEl.textContent = `Månedlig oversigt (${y})`;
  }

  function addBatteryParams(params) {
    params.set("battery_kwh", battKwhEl.value);
    params.set("soc_init", socInitEl.value);
    params.set("soc_min", socMinEl.value);
    params.set("soc_max", socMaxEl.value);

    // blank => don't send (backend will treat as None)
    if (pChargeEl.value !== "") params.set("p_charge_kw", pChargeEl.value);
    if (pDischargeEl.value !== "") params.set("p_discharge_kw", pDischargeEl.value);

    params.set("eta_charge", etaCEl.value);
    params.set("eta_discharge", etaDEl.value);
  }

  function openMonthlyModal() {
    document.getElementById("monthlyModal").style.display = "flex";
  }
  function closeMonthlyModal() {
    document.getElementById("monthlyModal").style.display = "none";
  }

  function renderMonthlyCharts(yearSim) {
    if (!yearSim || !yearSim.monthly) {
      throw new Error("Ingen årlig og månedlig data tilgængelig. Tryk på Opdater oversigt først");
    }

    const m = yearSim.monthly;
    const monthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

    const labels = m.month.map(s => {
      const mm = Number(String(s).split("-")[1]); 
      return monthNames[mm - 1];
    });

    // Destroy existing charts
    if (chartMonthlyEnergy) chartMonthlyEnergy.destroy();
    if (chartMonthlyCost) chartMonthlyCost.destroy();

    // 1) Monthly energy balance (stacked)
    chartMonthlyEnergy = new Chart(document.getElementById("chartMonthlyEnergy"), {
      type: "bar",
      data: {
        labels,
        datasets: [
          { label: "Forbrug (kWh)", data: m.load_kwh, stack: "kwh" },
          { label: "Solpanel (kWh)", data: m.pv_kwh, stack: "kwh" },
          { label: "Import (kWh)", data: m.import_kwh, stack: "kwh2" },
          { label: "Eksport (kWh)", data: m.export_kwh, stack: "kwh2" },
        ]
      },
      options: {
        responsive: true,
        scales: {
          x: { stacked: true },
          y: { stacked: true }
        }
      }
    });

    // 2) Monthly costs/savings (bars)
    chartMonthlyCost = new Chart(document.getElementById("chartMonthlyCost"), {
      type: "bar",
      data: {
        labels,
        datasets: [
          { label: "Årlige elomkostninger uden solceller (DKK)", data: m.baseline_cost_dkk },
          { label: "Årlige elomkostninger med solceller (DKK)", data: m.system_cost_dkk },
          { label: "Besparelser (DKK)", data: m.savings_dkk }
        ]
      },
      options: {
        responsive: true,
        scales: {
          x: { stacked: false },
          y: { stacked: false }
        }
      }
    });
  }

  function renderSimulationYear(data) {
    const s = data.summary;
    const year = getDisplayYear();

    function fmt(x, digits = 2) {
      if (x === null || x === undefined || Number.isNaN(Number(x))) return "—";
      return Number(x).toFixed(digits);
    }
    function pct(x) {
      if (x === null || x === undefined) return "—";
      return (Number(x) * 100).toFixed(1) + " %";
    }

    simYearEl.innerHTML = `
      <details class="section">
        <summary>
          Årlig simulation (${year})
          <span class="badge">${fmt(s.savings_dkk)} DKK</span>
        </summary>
        <div class="body">
          <details class="section" open>
            <summary>Estimerede beregninger</summary>
            <div class="body">
              <div class="row2">
                <div class="k">Årlige elomkostninger <b>uden</b> solceller</div>
                <div class="v">${fmt(s.baseline_cost_dkk)} DKK</div>

                <div class="k">Årlige elomkostninger <b>med</b> solceller</div>
                <div class="v">${fmt(s.system_cost_dkk)} DKK</div>

                <div class="k">Besparelser</div>
                <div class="v"><b>${fmt(s.savings_dkk)} DKK</b></div>

                <div class="k">Forbrug</div>
                <div class="v">${fmt(s.load_kwh)} kWh</div>

                <div class="k">Solpanel produktion</div>
                <div class="v">${fmt(s.pv_kwh)} kWh</div>
              </div>
            </div>
          </details>

          <details class="section" open>
            <summary>Dækningsgrader</summary>
            <div class="body">
              <div class="row2">
                <div class="k">Selvforbrug</div>
                <div class="v">${pct(s.self_consumption_ratio)}</div>

                <div class="k">Selvforsyningsgrad</div>
                <div class="v">${pct(s.self_sufficiency)}</div>
              </div>
            </div>
          </details>
        </div>
      </details>
    `;
  }


  function setSelected(lat, lon) {
    selected = {lat, lon};
    coord.textContent = `${lat.toFixed(5)}, ${lon.toFixed(5)}`;
    statusEl.textContent = "Lokation valgt. Tryk på Opdater oversigt.";

    if (marker) {
      marker.setLatLng([lat, lon]);
    }
  }

  function tip(text) {
    return `<span class="qm" data-tip="${escapeAttr(text)}">?</span>`;
  }

  function renderSummary(data) {
    const s = data.inputs;

    const locationStr = `${data.location.lat.toFixed(5)}, ${data.location.lon.toFixed(5)}`;
    const settingsStr = `kWp=${Number(s.kwp).toFixed(2)}, PR=${Number(s.pr).toFixed(2)}, tilt=${Number(s.tilt).toFixed(0)}°, az=${Number(s.az).toFixed(0)}°`;

    const peakPoa = Math.round(data.peak_poa_wm2);
    const peakPower = Math.round(data.peak_power_w);
    const yearKwh = Math.round(data.energy_year_kwh_tmy);

    const html = `
      <details class="section">
        <summary>
          Solpanel Resultater
          <span class="badge">${yearKwh} kWh/år</span>
        </summary>

        <div class="body">

          <details class="section" open>
            <summary>Energi resultater</summary>
            <div class="body">
              <div class="row2">
                <div class="k">Årlig total (TMY/PVGIS)</div>
                <div class="v">${yearKwh} kWh (år ${getDisplayYear()})</div>
              </div>
            </div>
          </details>

          <details class="section" open>
            <summary>Peak-værdier</summary>
            <div class="body">
              <div class="row2">
                <div class="k">Peak POA</div>
                <div class="v">${peakPoa} W/m²</div>

                <div class="k">Peak Solpanel effekt</div>
                <div class="v">${peakPower} W</div>
              </div>
            </div>
          </details>

          <details class="section" open>
            <summary>Energi (el) resultater</summary>
            <div class="body">
              <div class="row2">
                <div class="k">Årlig total (TMY/PVGIS)</div>
                <div class="v">${yearKwh} kWh (year ${escapeHtml(String(data.year))})</div>
              </div>
            </div>
          </details>

        </div>
      </details>
    `;


    summaryEl.innerHTML = html;

    // keep your plans rendering call:
    renderPlans(data.plan);
  }

  function applyLayerSwatches(layerControl, styleByDisplayName) {
    const root = layerControl.getContainer();

    // Add a title once
    if (!root.querySelector(".layers-title")) {
      const title = document.createElement("div");
      title.className = "layers-title";
      title.textContent = "Layers";
      root.insertBefore(title, root.firstChild);
    }

    // ---- 1) FIX BASE LAYERS: wrap text node into a span so spacing works ----
    const baseLabels = root.querySelectorAll(".leaflet-control-layers-base label");
    baseLabels.forEach(label => {
      const input = label.querySelector('input[type="radio"]');
      if (!input) return;

      // If already wrapped, do nothing
      if (label.querySelector("span.layer-name")) return;

      const name = label.textContent.trim(); // capture text BEFORE changing DOM

      const span = document.createElement("span");
      span.className = "layer-name";
      span.textContent = name;

      // Replace label contents with: [radio][span]
      label.replaceChildren(input, span);
    });

    // ---- 2) OVERLAYS: add swatches + ensure name span class ----
    const overlayLabels = root.querySelectorAll(".leaflet-control-layers-overlays label");
    overlayLabels.forEach(label => {
      const input = label.querySelector('input[type="checkbox"]');
      const span = label.querySelector("span"); // Leaflet creates span for overlays
      if (!input || !span) return;

      const name = span.textContent.trim();
      const st = styleByDisplayName[name];
      if (!st) return;

      span.classList.add("layer-name");

      let sw = label.querySelector(".layer-swatch");
      if (!sw) {
        sw = document.createElement("span");
        sw.className = "layer-swatch";
        label.appendChild(sw);
      }

      sw.style.borderColor = st.color || "#666";
      sw.style.background = st.fillColor || st.color || "#999";
      sw.style.opacity = (st.fillOpacity ?? 0.25);

      // Ensure order: input | name | swatch
      label.insertBefore(input, label.firstChild);
      label.insertBefore(span, input.nextSibling);
    });
  }

  function isUrl(s) {
    return typeof s === "string" && (s.startsWith("http://") || s.startsWith("https://"));
  }

  function niceLabel(key) {
    // Optional: rename keys to nicer labels
    const map = {
      plannavn: "Plan navn",
      planid: "Plan ID",
      plantype: "Plan type",
      status: "Status",
      doklink: "Dokument",
      link: "Link",
      url: "URL",
      doklink: "Dokument"
    };
    return map[key] || key;
  }

  function isEmptyVal(v) {
    return v === null || v === undefined || String(v).trim() === "";
  }

  function renderDetailSection(title, items) {
    const rows = items
      .filter(it => !isEmptyVal(it.value))
      .map(it => `
        <div class="detailRow">
          <div class="detailLabel">${escapeHtml(it.label)}</div>
          <div class="detailValue">${escapeHtml(String(it.value))}</div>
        </div>
      `)
      .join("");

    if (!rows) return "";

    return `
      <div class="detailSection">
        <div class="detailTitle">${escapeHtml(title)}</div>
        <div class="detailBody">${rows}</div>
      </div>
    `;
  }

  function renderDetails(details) {
    if (!details || !Array.isArray(details) || details.length === 0) {
      return "<div class='small'>Ingen ekstra detaljer.</div>";
    }

    const d = details[0];

    const sol = renderDetailSection("Sol", [
      { label: "Side", value: d.sol_side },
      { label: "Paragraf", value: d.sol_paragraf },
      { label: "Kommentar", value: d.kommentar_sol },
    ]);

    const vind = renderDetailSection("Vind", [
      { label: "Side", value: d.vind_side },
      { label: "Paragraf", value: d.vind_paragraf },
      { label: "Kommentar", value: d.kommentar_vind },
    ]);

    const batteri = renderDetailSection("Batteri", [
      { label: "Side", value: d.batteri_side },
      { label: "Paragraf", value: d.batteri_paragraf },
      { label: "Kommentar", value: d.kommentar_batteri },
    ]);

    const tekniske = renderDetailSection("Tekniske anlæg", [
      { label: "Side", value: d.tekniske_anlaeg_side },
      { label: "Paragraf", value: d.tekniske_anlaeg_paragraf },
      { label: "Kommentar", value: d.kommentar_tekniske_anlaeg },
    ]);

    const andet = renderDetailSection("Andet relevant regulering", [
      { label: "Side", value: d.andet_side },
      { label: "Paragraf", value: d.andet_paragraf },
      { label: "Kommentar", value: d.kommentar_andet_regulering },
    ]);

    const kort = renderDetailSection("Kort kommentar", [
      { label: "Kommentar", value: d.kommentar_kort },
    ]);

    const html = [sol, vind, batteri, tekniske, andet, kort].filter(Boolean).join("");

    return html || "<div class='small'>Ingen relevante områder fundet i detaljer.</div>";
  }

  function renderBevaringskode(data) {
    const code = data?.bevaringskode ?? null;

    if (code === null || code === undefined || String(code).trim() === "") {
      bevaringskodeEl.innerHTML = `
        <div><b>Bevaringskategori:</b> —</div>
        <div class="small">Ingen Bevaringskategori fundet for pågældende lokation (kontroller om markør står hvor husnummeret er vist).</div>
      `;
      return;
    }

    bevaringskodeEl.innerHTML = `
      <div><b>Bevaringskategori:</b> <span class="pill">${escapeHtml(String(code))}</span></div>
      <div class="small">Indikerer at bygningen har en gældende Bevaringskategori, kontroller gældende lovgivning for kategori.</div>
    `;
  }

  function renderPlans(plans) {
    if (!plansEl) return;

    const standardPlan = buildStandardPlan();

    // Always render ONE combined "Plans" section containing:
    // 1) Standard info (always shown)
    // 2) Lokalplan hits (if any)
    const parts = [];

    parts.push(`
      <details class="section" open>
        <summary>
          Planer og vejledning
          <span class="badge">${Array.isArray(plans) ? plans.length : 0}</span>
        </summary>
        <div class="body">
          ${renderStandardPlanItem(standardPlan)}
          ${renderFoundPlans(plans)}
        </div>
      </details>
    `);

    plansEl.innerHTML = parts.join("");
  }

  function renderFoundPlans(plans) {
    if (!plans || !Array.isArray(plans) || plans.length === 0) {
      return `<div class="small">Ingen lokalplaner fundet for det valgte punkt. Se “Standard vejledning” ovenfor.</div>`;
    }

    // Show a small count line (optional)
    const parts = [];
    parts.push(`<div class="small"><b>Fundet:</b> ${plans.length} plan(er)</div>`);

    plans.forEach((p, idx) => {
      const name = p.plannavn || p.plan_navn || p.navn || `Plan ${idx + 1}`;
      const id = p.planid ? String(p.planid) : "";
      const det = p.details?.[0] || {};

      function warn(flag, label) {
        return flag ? `<span class="warnPill">${escapeHtml(label)}</span>` : "";
      }

      const warnings = [
        warn(det.sol_relevant, "Sol"),
        warn(det.vind_relevant, "Vind"),
        warn(det.batteri_relevant, "Batteri"),
        warn(det.tekniske_anlaeg_relevant, "Teknik"),
        warn(det.andet_relevant_regulering, "Andet"),
      ].join("");

      parts.push(`
        <details class="planItem">
          <summary>
            ${escapeHtml(name)}
            ${id ? `<span class="pill">ID: ${escapeHtml(id)}</span>` : ""}
            ${warnings}
          </summary>
          <div class="planBody">
            <div class="kv">
              ${Object.entries(p).map(([k, v]) => {
                if (v === null || v === undefined || v === "") return "";

                // Keep your special rendering for details
                if (k === "details") {
                  return `<div style="grid-column: 1 / -1;">${renderDetails(v)}</div>`;
                }

                const keyLabel = niceLabel(k);
                const valStr = String(v);

                // Links become "Open document"
                if (isUrl(valStr)) {
                  return `
                    <div class="k">${escapeHtml(keyLabel)}</div>
                    <div class="v">
                      <a href="${escapeAttr(valStr)}" target="_blank" rel="noopener noreferrer">Åbn dokument</a>
                    </div>
                  `;
                }

                return `
                  <div class="k">${escapeHtml(keyLabel)}</div>
                  <div class="v">${escapeHtml(valStr)}</div>
                `;
              }).join("")}
            </div>
          </div>
        </details>
      `);
    });

    return parts.join("");
  }

  function renderStandardPlanItem(std) {
    // One collapsible planItem, same styling as the others
    return `
      <details class="planItem">
        <summary>
          ${escapeHtml(std.title)}
        </summary>
        <div class="planBody">
          <div class="small" style="margin-bottom: 10px;">
            ${escapeHtml(std.intro)}
          </div>

          <div class="kv">
            ${std.links.map(link => {
              return `
                <div class="k">${escapeHtml(link.label)}</div>
                <div class="v">
                  <a href="${escapeAttr(link.url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(link.linkText)}</a>
                  ${link.desc ? `<div class="small" style="margin-top:4px;">${escapeHtml(link.desc)}</div>` : ""}
                </div>
              `;
            }).join("")}
          </div>

          ${std.hints && std.hints.length
            ? `
              <div class="hr"></div>
              <div class="small"><b>Hvis der ikke findes en lokalplan ved punktet:</b></div>
              <ul class="small" style="margin: 8px 0 0 18px; padding: 0;">
                ${std.hints.map(h => `<li>${escapeHtml(h)}</li>`).join("")}
              </ul>
            `
            : ""
          }
        </div>
      </details>
    `;
  }

  function buildStandardPlan() {
    return {
      title: "Standard vejledning",
      intro:
        "Her er nyttige steder at starte – også selvom der er fundet en lokalplan. Brug dem til at forstå rammer, regler og bevaringsforhold.",
      links: [
        {
          label: "Rammer for lokalplanlægning",
          linkText: "Åbn rammer i DKPlan",
          url: "https://bornholm.viewer.dkplan.niras.dk/plan/24#/4487",
          desc: "Overblik over kommuneplanrammer og planlægning.",
        },
        {
          label: "Solceller, husstandsvind og jordvarme",
          linkText: "Åbn Bornholm.dk vejledning",
          url: "https://bornholm.dk/service-og-selvbetjening/by-og-bolig/byggeri-og-nedrivning/solcelleanlaeg-hustandsvindmoeller-jordvarme",
          desc: "Praktisk info om opførelse/ansøgning og typiske krav.",
        },
        {
          label: "Kort: fredning og bevaringsværdi",
          linkText: "Åbn kort",
          url: "https://drift.kortinfo.net/Map.aspx?page=ArealInformation&Site=Bornholm",
          desc: "Se fredede områder og fredede/bevaringsværdige bygninger.",
        },
        {
          label: "Aktuelle lokalplaner (index)",
          linkText: "Åbn lokalplan-index",
          url: "https://bornholm.viewer.dkplan.niras.dk/plan/23",
          desc: "Find og læs aktuelle lokalplaner på Bornholm.",
        },
        {
          label: "Retsinformation",
          linkText: "Åbn retsinformation.dk",
          url: "https://www.retsinformation.dk/",
          desc: "Søg i gældende love og bekendtgørelser (fx planloven og bygningsreglementet).",
        },
        {
          label: "Energiforbedring (SLKS PDF)",
          linkText: "Åbn vejledning (PDF)",
          url: "https://slks.dk/fileadmin/user_upload/SLKS/Omraader/Kulturarv/Bygningsfredning/Gode_raad_om_vedligeholdelse/13.1_Energiforbedring_af_fredede_og_bevaringsvaerdige_by.pdf",
          desc: "Gode råd til energiforbedringer af fredede og bevaringsværdige bygninger.",
        },
      ],
      hints: [
        "Tjek kortet for fredning/bevaringsværdi og se evt. Bevaringskode.",
        "Find relevante kommuneplanrammer (DKPlan) og lokale restriktioner.",
        "Slå de relevante regler op i Retsinformation (planlov, BR18 m.fl.).",
        "Hvis du er i tvivl: kontakt Bornholms Regionskommune med adresse/matrikel.",
      ],
    };
  }

  // Basic escaping to avoid breaking HTML if plan fields contain odd characters
  function escapeHtml(s) {
    return String(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#39;");
  }
  function escapeAttr(s) {
    // For href attributes
    return escapeHtml(s);
  }

  /* ===========================
    Azimuth measurement helpers
    =========================== */

  function normalizeDeg(deg) {
    let d = deg % 360;
    if (d < 0) d += 360;
    return d;
  }

  // Bearing from point A to B (0° = North, clockwise)
  function bearingDeg(a, b) {
    const lat1 = a.lat * Math.PI / 180;
    const lat2 = b.lat * Math.PI / 180;
    const dLon = (b.lng - a.lng) * Math.PI / 180;

    const y = Math.sin(dLon) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) -
              Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);

    const brng = Math.atan2(y, x) * 180 / Math.PI;
    return normalizeDeg(brng);
  }

  function makeAzimuthTool(map, azInputEl, statusEl, onStateChange) {
    let enabled = false;
    let dragging = false;
    let startLatLng = null;

    let arrowLine = null;
    let arrowHead = null;
    let tip = null;
    let perpTick = null;


    function clearGraphics() {
      if (arrowLine) { map.removeLayer(arrowLine); arrowLine = null; }
      if (arrowHead) { map.removeLayer(arrowHead); arrowHead = null; }
      if (tip) { map.removeLayer(tip); tip = null; }
      if (perpTick) { map.removeLayer(perpTick); perpTick = null; }
    }

    function setEnabled(on) {
      enabled = on;
      clearGraphics();
      dragging = false;
      startLatLng = null;

      if (enabled) {
        map.dragging.disable();
        map.doubleClickZoom.disable();
        statusEl.textContent = "Azimuth-værktøj: klik og træk for at måle retning.";
        map.getContainer().style.cursor = "crosshair";
      } else {
        map.dragging.enable();
        map.doubleClickZoom.enable();
        statusEl.textContent = "Azimuth-værktøj slået fra.";
        map.getContainer().style.cursor = "";
      }

      if (typeof onStateChange === "function") onStateChange(enabled);
    }

    function updateArrow(endLatLng) {
      const az = bearingDeg(startLatLng, endLatLng);
      azInputEl.value = String(Math.round(az));
      // --- Perpendicular tick at start point (screen-space so length is constant) ---
      const a = map.latLngToLayerPoint(startLatLng);
      const b = map.latLngToLayerPoint(endLatLng);

      const vx = b.x - a.x;
      const vy = b.y - a.y;
      const vlen = Math.hypot(vx, vy);

      // Only draw if user has moved enough pixels (avoid NaNs when start=end)
      if (vlen > 2) {
        // Unit perpendicular vector
        const px = -vy / vlen;
        const py =  vx / vlen;

        const tickLenPx = 24; // adjust to taste
        const half = tickLenPx / 2;

        const p1 = L.point(a.x + px * half, a.y + py * half);
        const p2 = L.point(a.x - px * half, a.y - py * half);

        const ll1 = map.layerPointToLatLng(p1);
        const ll2 = map.layerPointToLatLng(p2);

        if (!perpTick) {
          perpTick = L.polyline([ll1, ll2], {
            color: "red",
            weight: 3,
            opacity: 0.9
          }).addTo(map);
        } else {
          perpTick.setLatLngs([ll1, ll2]);
        }
      }


      const lineLatLngs = [startLatLng, endLatLng];
      if (!arrowLine) {
        arrowLine = L.polyline(lineLatLngs, {
          color: "#111",
          weight: 3
        }).addTo(map);
      } else {
        arrowLine.setLatLngs(lineLatLngs);
      }

      const html = `<div class="az-arrow-head" style="transform: rotate(${az}deg);">▲</div>`;
      const icon = L.divIcon({ className: "", html, iconSize: [20,20], iconAnchor: [10,10] });

      if (!arrowHead) {
        arrowHead = L.marker(endLatLng, { icon, interactive:false }).addTo(map);
      } else {
        arrowHead.setLatLng(endLatLng);
        arrowHead.setIcon(icon);
      }

      const label = `Azimuth: ${Math.round(az)}°`;

      if (!tip) {
        tip = L.marker(endLatLng, {
          icon: L.divIcon({
            className: "az-tip",
            html: `<div>${label}</div>`,
            iconSize: [120,24],
            iconAnchor: [10,30]
          }),
          interactive:false
        }).addTo(map);
      } else {
        tip.setLatLng(endLatLng);
        tip.setIcon(L.divIcon({
          className: "az-tip",
          html: `<div>${label}</div>`,
          iconSize: [120,24],
          iconAnchor: [10,30]
        }));
      }
    }

    function onMouseDown(e) {
      if (!enabled) return;
      dragging = true;
      startLatLng = e.latlng;
      clearGraphics();
      updateArrow(e.latlng);
    }

    function onMouseMove(e) {
      if (!enabled || !dragging) return;
      updateArrow(e.latlng);
    }

    function onMouseUp(e) {
      if (!enabled || !dragging) return;
      dragging = false;
      const az = bearingDeg(startLatLng, e.latlng);
      azInputEl.value = String(Math.round(az));
      setEnabled(false); // auto turn off after use
    }

    map.on("mousedown", onMouseDown);
    map.on("mousemove", onMouseMove);
    map.on("mouseup", onMouseUp);

    return {
      toggle: () => setEnabled(!enabled),
      isEnabled: () => enabled
    };
  }


  async function init() {
    const extraOverlays = {}; // name -> Leaflet layer
    const center = await getJSON("/api/center");
    plansEl.innerHTML = "<div class='small'>Tryk “Opdater oversigt” for at se planer og vejledning.</div>";
    // Map
    const map = L.map("map").setView([center.lat, center.lon], 10);

    // ===== Azimuth tool =====
    let azBtn = null;

    const azTool = makeAzimuthTool(map, azEl, statusEl, (enabled) => {
      if (!azBtn) return;
      azBtn.textContent = enabled ? "Stop retning / azimuth" : "Mål retning / azimuth";
      azBtn.classList.toggle("active", enabled);
    });

    const AzControl = L.Control.extend({
      onAdd: function() {
        const btn = L.DomUtil.create("button");
        btn.type = "button";
        btn.textContent = "Mål retning / azimuth";
        btn.className = "az-btn";
        azBtn = btn;

        L.DomEvent.disableClickPropagation(btn);
        L.DomEvent.on(btn, "click", (e) => {
          L.DomEvent.stop(e);
          azTool.toggle(); // callback updates text + class
        });

        return btn;
      }
    });

    map.addControl(new AzControl({ position: "bottomleft" }));

    // ----- Base layers -----

    // OpenStreetMap
    const osm = L.tileLayer(
      "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
      {
        minZoom: 10,
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors"
      }
    );

    // Esri satellite
    const esriSat = L.tileLayer(
      "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
      {
        minZoom: 10,
        maxZoom: 19,
        attribution: "Tiles © Esri"
      }
    );

    // Default layer shown when map loads
    osm.addTo(map);


    // Marker visible immediately (like original)
    marker = L.marker([center.lat, center.lon]).addTo(map);
    setSelected(center.lat, center.lon);

    // ----- Layers from backend config (/api/layers) -----
    const overlays = {};
    const styleByDisplayName = {};

    const layersResp = await getJSON("/api/layers");
    const layerMeta = layersResp.layers || [];
    
    let boundsLayer = null;

    for (const info of layerMeta) {
      const gj = await getJSON(`/api/layers/${encodeURIComponent(info.id)}`);

      const style = info.style || { color: "#666", weight: 2, fillOpacity: 0.10 };

      const gjLayer = L.geoJSON(gj, {
        style,
        onEachFeature: (feature, layer) => {
          layer.on("click", (e) => setSelected(e.latlng.lat, e.latlng.lng));
        }
      });

      // Swatches keyed by the displayed GUI name
      styleByDisplayName[info.name] = style;

      // Add to layer control only if allowed
      if (info.show_in_control) {
        overlays[info.name] = gjLayer;
      }

      // Add to map by default if enabled
      if (info.enabled_by_default) {
        gjLayer.addTo(map);
        if (!boundsLayer) boundsLayer = gjLayer;
      }
    }

    // Optional: fit to the first default-enabled layer (if it exists)
    if (boundsLayer && boundsLayer.getBounds && boundsLayer.getBounds().isValid()) {
      const b = boundsLayer.getBounds();
      map.fitBounds(b.pad(0.15));
      map.setMaxBounds(b.pad(0.25));
    }

    L.Control.geocoder({
      defaultMarkGeocode: false,
      placeholder: "Indtast adresse",
      collapsed: false
    })
    .on('markgeocode', function(e) {
      const latlng = e.geocode.center;

      setSelected(latlng.lat, latlng.lng);  // your existing function
      map.setView(latlng, 15);

      if (marker) marker.setLatLng(latlng);
    })
    .addTo(map);

    // Map click (works everywhere not caught by polygons)
    map.on("click", (e) => {
      setSelected(e.latlng.lat, e.latlng.lng);
    });

    // ----- Layer control (built from config-loaded overlays) -----
    const baseLayers = {
      "OpenStreetMap": osm,
      "Satellite (Esri)": esriSat
    };

    const layerControl = L.control.layers(baseLayers, overlays, { collapsed: false }).addTo(map);

    // Add swatches once (must happen AFTER control is added)
    setTimeout(() => applyLayerSwatches(layerControl, styleByDisplayName), 0);

    // Buttons
    document.getElementById("btnSummary").onclick = async () => {
      if (!selected) {
        statusEl.textContent = "Klik på kort for at vælge lokation.";
        return;
      }

      statusEl.textContent = "Beregner resultater…";
      
      const params = new URLSearchParams({
        lat: selected.lat,
        lon: selected.lon,
        kwp: kwpEl.value,
        pr: prEl.value,
        tilt: tiltEl.value,
        az: azEl.value,
        annual_kwh: annualKwhEl.value,
      });

      params.set("price_scenario", priceScenarioEl.value);

      try {
        bevaringskodeEl.innerHTML = "<div class='small'>Looking up Bevaringskode…</div>";
        const bk = await getJSON(`/api/bevaringskode?lat=${selected.lat}&lon=${selected.lon}`);
        renderBevaringskode(bk);
      } catch (e) {
        bevaringskodeEl.innerHTML = "<div class='small'>Bevaringskode lookup failed.</div>";
      }

      addBatteryParams(params);

      // show some progress in the UI (optional but nice)
      if (typeof simYearEl !== "undefined" && simYearEl) simYearEl.innerHTML = "<div class='small'>Running yearly simulation…</div>";

      try {
        // 1) PV summary
        const summary = await getJSON(`/api/summary?${params.toString()}`);
        lastSummary = summary;
        renderSummary(summary);

        // 2) Day simulation (removed function)

        // 3) Year simulation
        const year = "2025";
        const yearParams = new URLSearchParams({
          lat: selected.lat,
          lon: selected.lon,
          kwp: kwpEl.value,
          pr: prEl.value,
          tilt: tiltEl.value,
          az: azEl.value,
          year: year,
          annual_kwh: annualKwhEl.value,
        });

        yearParams.set("price_scenario", priceScenarioEl.value);
        addBatteryParams(yearParams);

        lastYearSim = await getJSON(`/api/simulate_year?${yearParams.toString()}`);
        const yearSim = await getJSON(`/api/simulate_year?${yearParams.toString()}`);
        renderSimulationYear(yearSim);

        statusEl.textContent = "Alle resultater opdateret.";
      } catch (err) {
        statusEl.textContent = "Fejl under beregning af resultater.";
        console.error(err);

        // show errors in the boxes if present
        if (typeof simEl !== "undefined" && simEl) {
          simEl.innerHTML = "<pre class='small'>Fejl:\n" + escapeHtml(String(err)) + "</pre>";
        }
        if (typeof simYearEl !== "undefined" && simYearEl) {
          simYearEl.innerHTML = "<pre class='small'>Fejl:\n" + escapeHtml(String(err)) + "</pre>";
        }
      }
    };

      // Modal close button
    document.getElementById("btnMonthlyClose").onclick = closeMonthlyModal;

    // Click outside card closes modal
    document.getElementById("monthlyModal").onclick = (e) => {
      if (e.target.id === "monthlyModal") closeMonthlyModal();
    };

    // Monthly overview button
    document.getElementById("btnMonthly").onclick = () => {
      try {
        renderMonthlyCharts(lastYearSim);
        openMonthlyModal();
        statusEl.textContent = "Månedlig oversigt åbnet.";
      } catch (err) {
        statusEl.textContent = String(err);
        console.error(err);
      }
    };

    priceScenarioEl.addEventListener("change", () => {
      refreshYearLabels();
    });

    refreshYearLabels();

  }

  init().catch(err => {
    summaryEl.textContent = "Init error:\n" + err;
    statusEl.textContent = "Fejl under initialisering. Se detaljer i output.";
    console.error(err);
  });
</script>
</body>
</html>
